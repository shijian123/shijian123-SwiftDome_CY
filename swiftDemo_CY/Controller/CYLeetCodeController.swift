//
//  CYLeetCodeController.swift
//  swiftDemo_CY
//
//  Created by zcy on 2020/8/3.
//  Copyright © 2020 CY. All rights reserved.
//

import UIKit

class CYLeetCodeController: CYBaseController {

    override func viewDidLoad() {
        super.viewDidLoad()
        //1. 两数之和
//        twoSum([4,7,2,11], 8)
        
        //7. 整数反转
//        reverse(-123)
        
        // 9. 回文数
//        isPalindrome(1234567890)
        
        // 13. 罗马数字转整数
//        romanToInt("MCMXCIV")
        
        // 14. 最长公共前缀
//        let resultStr = longestCommonPrefix(["flower","er"])
//        print("resultStr:\(resultStr)")

        // 20. 有效的括号
//        let result = isValid("([{}])")
//        print("resultStr:\(result)")

        // 21. 合并两个有序链表
//        mergeTwoLists([1,2,4], [1,3,4])
        
        // 26. 删除排序数组中的重复项
//        var nums = [1,1,2,2,3]
//        removeDuplicates(&nums)
        
        // 27. 移除元素
//        var nums = [2,3,4,3,2]
//        removeElement(&nums, 3)
        
        // 28. 实现 strStr()
//        print(strStr("adjjkkkp","p"))
        
        // 35. 搜索插入位置
//        searchInsert([1,3,5,7], 2)
        
        // 38. 报数
//        countAndSay(3)
        
        // 53. 最大子序和
//        maxSubArray([-2,-1,-3,-5])
        
        // 58. 最后一个单词的长度
//        lengthOfLastWord("a")
        
        // 66. 加一
//        plusOne([1,2,3,4,5,6,9,9,9,9,9])
        
        // 67. 二进制求和
//        addBinary("1010", "1011")
        
        // 69. x 的平方根
//        mySqrt(12)
        
        // 70. 爬楼梯
//        climbStairs(5)
        
        // 83. 删除排序链表中的重复元素
//        deleteDuplicates([1,2,2,4])
        
        // 88. 合并两个有序数组
//        var nums = [2,0]
//        merge(&nums, 1, [1], 1)
        
        // 100. 相同的树
//        isSameTree([1,2,3], [1,2,4])
        
        // 101. 对称二叉树
//        isSymmetric([1,2,2,3,4,4,3])
        
        // 104. 二叉树的最大深度
//        maxDepth([3,9,20,null,null,15,7])
        
        // 107. 二叉树的层次遍历 II
//        levelOrderBottom([3,9,20,null,null,15,7])
        
        
        // 108. 将有序数组转换为二叉搜索树
//        sortedArrayToBST([-10,-3,0,5,9])
        
        // 110. 平衡二叉树
//        isBalanced([3,9,20,null,null,15,7])
        
        // 111. 二叉树的最小深度
//        minDepth([3,9,20,null,null,15,7])
        
        // 112. 路径总和
//        hasPathSum([5,4,8,11,null,13,4,7,2,null,null,null,1], 22)
        
        // 118. 杨辉三角
//        let arr: [[Int]] = generate(5)
//        print("arr", arr)
        
        /// 119. 杨辉三角 II
//        let arr: [Int] = getRow(4)
//        print("arr：",arr)
        
        /// 121. 买卖股票的最佳时机
//        maxProfit([7,2,4,5,1])
        
        /// 122. 买卖股票的最佳时机 II
//        maxProfit2([7,2,4,5,1])

        /// 125. 验证回文串
        isPalindrome("A man, a plan, a canal: Panama")
        
        //136. 只出现一次的数字
//        singleNumber([1,2,3,4,5,5,3,2,1])
        
        
    }
    
    /// 1.两数之和
    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
        //1、暴力不好
//        for x in 0..<nums.count {
//            for y in (x+1)..<nums.count {
//                if nums[x]+nums[y] == target {
//                    print("x:\(x), y:\(y)")
//                    return [x, y]
//                }
//            }
//        }
//        return []
        
        // 按照字典，数组中数字为key, 索引为value
        var dict = [Int: Int]()
        
        for index in 0..<nums.count {
            dict[nums[index]] = index
        }
        
        for x in 0..<nums.count {
            let num = target - nums[x]
            if let y = dict[num], y != x {
                print("x:\(x), y:\(y)")
                return [x, y]
            }
        }
        return []
    }
    
    /// 7. 整数反转
    func reverse(_ x: Int) -> Int {
        var num: Double = 0
        var originNum = x
        while originNum != 0 {
            num = num*10 + Double(originNum % 10)
            originNum = originNum/10
        }
        
        // 超出返回0 32 位的有符号整数,运用指数运算pow
        if num < pow(-2, 31) || num > (pow(2, 31) - 1) {
            return 0
        }
        
//        print(Int(num))
        return Int(num)
    }
    
    /// 9. 回文数
    func isPalindrome(_ x: Int) -> Bool {
        // 回文数一定不为负数、最后一位一定不为0、不会溢出，只要溢出反转数就为0了
        if x < 0 || (x%10 == 0 && x != 0) {
            return false
        }
        
        var num: Double = 0
        var originNum = x
        while originNum != 0 {
            num = num*10 + Double(originNum % 10)
            originNum = originNum/10
        }
        
        // 超出返回0 32 位的有符号整数,运用指数运算pow
        if num < pow(-2, 31) || num > (pow(2, 31) - 1) {
            return false
        }
        
        return num == Double(x)
        
    }
    
    
    /// 13. 罗马数字转整数 MCMXCIV
    func romanToInt(_ s: String) -> Int {
        let dic = ["I":1, "V":5, "X":10, "L":50, "C":100, "D":500, "M": 1000]
        var num = 0
        for (i, value) in s.enumerated() {
            // 判断当前循环是否是最后一个或者当前罗马数字对应的值是否比后面的值更大，更大则加，更小则减
            // 根据下标获取下一个罗马数字
            if i == s.count-1 || dic[String(s[s.index(s.startIndex, offsetBy: i+1)..<s.index(s.startIndex, offsetBy: i+2)])]! <= dic[String(value)]! {
                num += dic[String(value)]!
            }else {
                num -= dic[String(value)]!
            }

        }
        //print("罗马数字转整数:\(num)")
        return num
    }
    
    /// 14. 最长公共前缀 取出第一个字符串，使用后面的字符串判断第一个字符串是否是他们的前缀，不是则将第一个字符串长度减一，继续判断
    func longestCommonPrefix(_ strs: [String]) -> String {
        let count = strs.count
        if count == 0 {
            return ""
        }else if count == 1 {
            return strs.first!
        }else {
            // 默认取第一个，虽然可能是最长的一个
            var resultStr = strs.first!
            
            for i in 1..<count {
                while !strs[i].hasPrefix(resultStr) {
                    resultStr = String(resultStr.prefix(resultStr.count - 1))
                    if resultStr.count == 0 {
                        return ""
                    }
                    print(resultStr)
                }
            }
            return resultStr
        }
    }
    
    /// 20. 有效的括号
    func isValid(_ s: String) -> Bool {
        
        //这个太费了
//        var str = s
//        while str.contains("{}") || str.contains("[]") || str.contains("()") {
//            str = str.replacingOccurrences(of: "{}", with: "")
//            str = str.replacingOccurrences(of: "[]", with: "")
//            str = str.replacingOccurrences(of: "()", with: "")
//
//        }
//        return str == ""
        
        if s.count == 0 {
            return true
        }else if s.count % 2 == 1 {// 奇数必为false
            return false
        }else {// {、[、( 必在前面，否则false，然后根据这个特性
            var arr: [Character] = []
            for char in s {
                if let last = arr.last {
                    let ret = (last == "(" && char == ")") || (last == "[" && char == "]") || (last == "{" && char == "}")
                    if ret {
                        arr.removeLast()
                        }else {
                        arr.append(char)
                    }
                }else {
                    arr.append(char)
                }
            }
            return arr.count == 0
        }
        
    }
    
    
    /// 21. 合并两个有序链表
    func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
        if l1 == nil {
            return l2
        }else if l2 == nil {
            return l1
        }else {
            if l1!.val < l2!.val {
                l1!.next = mergeTwoLists(l1!.next, l2)
                return l1
            }else {
                l2!.next = mergeTwoLists(l2!.next, l1)
                return l2
            }
        }
    }
    
    public class ListNode {
        public var val: Int
        public var next: ListNode?
        public init(_ val: Int) {
            self.val = val
            self.next = nil
        }
    }
    
    /// 26. 删除排序数组中的重复项
    func removeDuplicates(_ nums: inout [Int]) -> Int {
        //1、首先先看好题，这是一个有序的数组！！！2、由于是一个有序的数组，所以相等的的数一定是紧密排列的
        if nums.count == 0 {
            return 0
        }
        
        var i = 0
        for j in 1..<nums.count {
            if nums[j] != nums[i] {
                i += 1
                nums[i] = nums[j]
            }
        }
        print(nums[0...i])
        return i+1
        
    }
    
    /// 27. 移除元素
    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {
        // 按照26题的思路，可将不等于val的值提到前面去
        
        if nums.count == 0 {
            return 0
        }
        
        var i = 0
        for j in 0..<nums.count {
            if nums[j] != val {
                nums[i] = nums[j]
                i += 1
            }
        }
        print(nums[0...i])
        return i+1
        
    }
    
    /// 28. 实现 strStr()
    func strStr(_ haystack: String, _ needle: String) -> Int {
        
        guard !needle.isEmpty || haystack != needle else {
            return 0
        }

        if haystack.count < needle.count {
            return -1
        }
        
        let hCount = haystack.count
        let nCount = needle.count
        
        for i in 0..<hCount-nCount {
            
            let firstIndex = haystack.index(haystack.startIndex, offsetBy: i)
            let endIndex = haystack.index(haystack.startIndex, offsetBy: i+nCount)
            if haystack[firstIndex..<endIndex] == needle {
                return i
            }
        }
        return -1
    }
    
    /// 35. 搜索插入位置
    func searchInsert(_ nums: [Int], _ target: Int) -> Int {
        
        guard nums.count != 0 else {
            return 0
        }
        if target <= nums.first! {
            return 0
        }else if target == nums.last! {
            return nums.count-1
        }else if target > nums.last! {
                return nums.count
        }else {// 1357   6
            for i in 0..<nums.count-1 {
                if nums[i] <= target && nums[i+1] >= target {
                    return i+1
                }
            }
            return nums.count
        }
    }
    
    /// 38. 报数
    func countAndSay(_ n: Int) -> String {
        let dic = [
            1:"1",
            2:"11",
            3:"21",
            4:"1211",
            5:"111221",
            6:"312211",
            7:"13112221",
            8:"1113213211",
            9:"31131211131221",
            10:"13211311123113112211",
            11:"11131221133112132113212221",
            12:"3113112221232112111312211312113211",
            13:"1321132132111213122112311311222113111221131221",
            14:"11131221131211131231121113112221121321132132211331222113112211",
            15:"311311222113111231131112132112311321322112111312211312111322212311322113212221",
            16:"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211",
            17:"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221",
            18:"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211",
            19:"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221",
            20:"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211",
            21:"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221",
            22:"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211",
            23:"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221",
            24:"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211",
            25:"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221",
            26:"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211",
            27:"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221",
            28:"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211",
            29:"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221",
            30:"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"]
        return dic[n] ?? ""
    }
    
    
    /// 53. 最大子序和
    // 连续
    // [-2,1,-3,4,-1,2,1,-5,4] 6
    func maxSubArray(_ nums: [Int]) -> Int {    //1、遍历时，如果加上正数，和会增加；加上一个负数，和会减小；2、如果这个和为负数，则应该重置，且每次都需将此次的和与上一次的和比较保存最大的那个和
        var sum: Int = nums[0]
        var currentSum: Int = nums[0]
        for i in 1..<nums.count {
            if currentSum < 0 {
                currentSum = nums[i]
            }else {
                currentSum += nums[i]
            }
            
            if currentSum > sum {
                sum = currentSum
            }
        }
        return sum
    }

    /// 58. 最后一个单词的长度
    func lengthOfLastWord(_ s: String) -> Int {
        let arr = s.components(separatedBy: " ")
        
//        for i in 0..<arr.count {
//            let str = arr[arr.count-1-i]
//            if str.count > 0 {
//                return str.count
//            }
//        }
        
        // 这两个耗时类似，reversed()仅仅只是调整了下标
        for str in arr.reversed() {
            if str.count > 0 {
                return str.count
            }
        }
        
        return 0
    }
    
//    给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
//
//    最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
//
//    你可以假设除了整数 0 之外，这个整数不会以零开头。

    /// 66. 加一
//1、由于将数组转化为数字将其+1再转为数组，会有溢出发生//2、从数组的末位开始取，将其加一返回数组，当前位若为9，则需进一位，即在遍历+1时，取余替换当前值，若取余的值为0，则表示需要进一位便继续遍历，直到取余不为0，若遍历后余数都为0，则数组内的数字全部为9，即在数组首位插入1
    func plusOne(_ digits: [Int]) -> [Int] {

        var digits = digits
        for i in (0..<digits.count).reversed() {
            let sum = digits[i] + 1
            digits[i] = sum % 10
            if digits[i] != 0 {
                return digits
            }
        }
        // 如果运行到这里，则表示数组全部为9
        digits.insert(1, at: 0)
        return digits
    }
    
    /// 67. 二进制求和
    func addBinary(_ a: String, _ b: String) -> String {

        
        /**
         1、转整数【Int(a, radix:2)】再相加的方案，无法处理溢出的情况
         2、Swift 中 String 不支持直接下标随机访问，需要先转为数组
         */
//        let aChars = Array(a), bChars = Array(b)
//        var sum = 0, carry = 0, res = ""
//        var i = aChars.count - 1, j = bChars.count - 1
//
//        while i >= 0 || j >= 0 || carry > 0 {
//            let bitA: Int = {
//                if i < 0 { return 0 }
//                defer { i -= 1 }
//                return Int(String(aChars[i]))!
//            }()
//            let bitB: Int = {
//                if j < 0 { return 0 }
//                defer { j -= 1 }
//                return Int(String(bChars[j]))!
//            }()
//
//            sum = bitA ^ bitB ^ carry
//            carry = (bitA & bitB) | (carry & (bitA | bitB))
//
//            res = String(sum) + res
//        }
//        return res
        
        
        /**
         思路：
         1、转成整数相加的方法，会出现溢出的情况
         2、遍历异或法：二进制求和，可将其认为两个数组中的元素对应相加，若相加和为1，则需置为0并进一位
         3、使用异或可以很方便的得到当前的值及是否需要进一位，是否进一位的条件为：numA和numB均为1 或 carry=1且numA、numB中有一个为1
         4、当循环结束时carry必为0
         */
        
        let aChars = Array(a), bChars = Array(b)
        var i = aChars.count - 1, j = bChars.count - 1
        var sum = 0, carry = 0, str = ""

        while i >= 0 || j >= 0 || carry > 0{
            let numA:Int = {
                if i < 0 { return 0 } // 如果a字符串最短
                // defer 所声明的 block 会在当前代码执行退出后被调用；正因为它提供了一种延时调用的方式，所以一般会被用来做资源释放或者销毁
                defer {i -= 1}
                return Int(String(aChars[i]))!
            }()
            
            let numB: Int = {
                if j < 0 { return 0 }// 如果b字符串最短
                defer {j -= 1}
                return Int(String(bChars[j]))!
            }()
            
            // 使用异或运算
            sum = numA ^ numB ^ carry
            carry = (numA & numB) | (carry & (numA | numB))
            
            str = String(sum) + str
        }
        return str
    }
    
    
    /// 69. x 的平方根
    func mySqrt(_ x: Int) -> Int {
        // 有点不好意思
        return Int(Double(x).squareRoot())
    }
    
    /// 70. 爬楼梯
    /**
    发现规律

    爬上n阶台阶 = 爬上n-1阶台阶再爬1阶 + 爬上n-2阶台阶再爬2阶
    爬上n-1阶台阶 =  爬上n-2阶台阶再爬1阶  +  爬上n-3阶台阶再爬2阶
    爬上n-2阶台阶 =  爬上n-3阶台阶再爬1阶  +  爬上n-4阶台阶再爬2阶
    
    可知这是一个斐波那契数列，当前项为前两项的和，即
    f(n) = n                   n=1,2
    f(n) = f(n-1)+f(n-2)       n>2
    
    每次都只需要记得当前是第几项，已写数列的最后两项是什么，然后算出新项，然后再只需要记得当前的项数以及最后两项……如此不断反复，直到写完。
    */
    func climbStairs(_ n: Int) -> Int {
        
        if n < 3 {
           return n
         }
        var a = 1
        var b = 2
        var res = 0
        
        for _ in 2..<n {
            res = a + b
            a = b
            b = res
        }

        return res
        
    }
    
    
    /// 83. 删除排序链表中的重复元素
    /**
    1、找终止条件：当head指向链表只剩一个元素的时候，自然是不可能重复的，因此return
    想想应该返回什么值：应该返回的自然是已经去重的链表的头节点
    2、每一步要做什么：宏观上考虑，此时head.next已经指向一个去重的链表了，而根据第二步，我应该返回一个去重的链表的头节点。因此这一步应该做的是判断当前的head和head.next是否相等，如果相等则说明重了，返回head.next，否则返回head

    */
    func deleteDuplicates(_ head: ListNode?) -> ListNode? {
        var head = head
        if(head == nil || head?.next == nil){
            return head;
        }
        head?.next = deleteDuplicates(head?.next);
        if(head?.val == head?.next?.val){
            head = head?.next;
        }
        return head;
        
    }
    
    
    /// 88. 合并两个有序数组
    /**
     思路：
     1、如果正序比对，还需考虑位移问题，如果倒序比较则相对简单了许多
     2、倒序比较时，以最长的元素数为最大遍历量，当每次比较两个数值，并将最大值保存到i+j+1的下标上，需注意i和j必须不能为负值
     3、有个特殊情况，当m为0时，nums2即为合并后的数组
     */
    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {

        var i = m-1, j = n-1
        if m == 0 {// 若m为0，则表示nums2数组即为最后的数组
            nums1 = nums2
        }else {
            while i >= 0 || j >= 0{
                if j<0 || (i >= 0 && j>=0 && nums1[i]>nums2[j]){
                    nums1[i+j+1] = nums1[i]
                    i -= 1
                }else {
                    nums1[i+j+1] = nums2[j]
                    j -= 1
                }
            }
        }
        print(nums1)
    }
    
    
    /// 100. 相同的树
    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {
        if p == nil && q == nil {
            return true
        }else if (p == nil && q != nil) || (p != nil && q == nil) {
            return false
        }else if p?.val == q?.val {
            return isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)
        }else {
            return false
        }
    }
    
    public class TreeNode {
        public var val: Int
        public var left: TreeNode?
        public var right: TreeNode?
        public init(_ val: Int) {
                self.val = val
                self.left = nil
                self.right = nil
            }
        }
    
    
    /// 101. 对称二叉树
    /**1、使用递归法
     */
    func isSymmetric(_ root: TreeNode?) -> Bool {
       return isSameMirrorTree(root, root)
    }
    // 二叉树镜像，判断这两个节点是否相等
    func isSameMirrorTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {
        if p == nil  && q == nil{
            return true
        }else if p == nil || q == nil{
            return false
        }else {
            return (p?.val == q?.val) && (isSameMirrorTree(p?.left, q?.right)) && (isSameMirrorTree(p?.right, q?.left))
        }
    }
    
    /// 104. 二叉树的最大深度
    func maxDepth(_ root: TreeNode?) -> Int {
        if root == nil {
            return 0
        }
        
        let leftDepth = maxDepth(root?.left)
        let rightDepth = maxDepth(root?.right)
        
        return max(leftDepth, rightDepth)+1
        
    }
    
    /// 107. 二叉树的层次遍历 II
    func levelOrderBottom(_ root: TreeNode?) -> [[Int]] {
        
        guard let r = root else {return [[Int]]()}
        var result = [[Int]]()
        var queue = [TreeNode]()
        queue.append(r)
        while queue.count > 0 {
            let layer = Array(queue)
            var layerVal = [Int]()
            queue.removeAll()
            for node in layer {// 每次都取出一层的所有数据， 并添加到最前面
                layerVal.append(node.val)
                if let ln = node.left {
                    queue.append(ln)
                }
                if let rn = node.right {
                    queue.append(rn)
                }
            }
            result.insert(layerVal, at: 0)
        }
        return result
        
    }
    
    /// 108. 将有序数组转换为二叉搜索树
    /**
    首先这是一个有序数组，且平衡二叉树的条件有两个：
    1、根节点大于左子树任意节点，小于右子树任意节点；
    2、左右子数高度相差不超过 1；
    所以可得出一个递归的条件：每次返回的根节点处于数组中间，以其左右半数组分别递归构造左右子树
     */
    func sortedArrayToBST(_ nums: [Int]) -> TreeNode? {
        return generateBST(nums, 0, nums.count-1)
    }
 
    func generateBST(_ nums: [Int], _ left: Int, _ right: Int) -> TreeNode? {
        if left > right { return nil }
        let mid = (left + right)/2
        let node = TreeNode(0)
        node.val = nums[mid]
        node.left = generateBST(nums, left, mid-1)
        node.right = generateBST(nums, mid+1, right)
        
        return node
    }
    

    /// 110. 平衡二叉树
    // 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1
    /**
    附上一个我觉得很啰嗦的解法...但是我觉得树的递归大部分都可以这么套路的解决，相当于一个解题模版（初学数据结构的菜鸡orz
    模版一共三步，就是递归的三部曲：
    找终止条件：什么时候递归到头了？此题自然是root为空的时候，空树当然是平衡的。
    思考返回值，每一级递归应该向上返回什么信息？参考我代码中的注释。
    单步操作应该怎么写？因为递归就是大量的调用自身的重复操作，因此从宏观上考虑，只用想想单步怎么写就行了，左树和右树应该看成一个整体，即此时树一共三个节点：root，root.left，root.right。
    */
    func isBalanced(_ root: TreeNode?) -> Bool {
        // 返回树深度，如果树深度为-1就是不平衡
        return treeCount(root) != -1
    }
    
    // 因为 height 不可能为负数，所以这里使用 -1 作为不平衡的一个标志。如果返回 -1，就说明子树中存在不平衡的情况，然后就返回 -1，最终退出递归过程。
    func treeCount(_ root: TreeNode?) -> Int {
        if root == nil { return 0 }
        let countLeft = treeCount(root!.left)
        if countLeft == -1 { return -1 }
        let countRight = treeCount(root!.right)
        if countRight == -1 { return -1 }
        return abs(countLeft - countRight) < 2 ? max(countLeft, countRight) + 1 : -1
    }
    
    /// 111. 二叉树的最小深度
    //        思路：
    //        树还是使用递归法
    //        结束条件：节点为nil
    //        返回值：当前节点深度
    //        单步操作：取左右节点的最小值+本次
    func minDepth(_ root: TreeNode?) -> Int {
        
        if root == nil {
            return 0
        }
        let left = minDepth(root?.left)
        let right = minDepth(root?.right)
        // 主要避免[1,2]这种情况
        return (left != 0 && right != 0) ? min(left, right)+1 : 1+left+right
    }
    
    /// 112. 路径总和
    /*
     思路：
     二叉树使用递归法
     终止条件：root为nil，返回false
     返回值：当前的是否符合条件
     单步操作：将sum减去每次的节点值如果在叶子节点的时候sum为0，则返回true
     **/
    func hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {
        
        if root == nil {
            return false
        }
        
        if root?.left == nil && root?.right == nil {// 叶子节点
            return (sum - (root?.val ?? 0)) == 0
        }

        return hasPathSum(root?.left, sum-(root?.val ?? 0)) || hasPathSum(root?.right, sum-(root?.val ?? 0))
    }
    
    /// 118. 杨辉三角
    /*
     如果单纯只是输出结果，确实不复杂，两个循环加上一个递归方法就能解决问题，代码也很优雅。但是提交的时候却没有通过，提示执行超时，显示的测试用例是输入数为30。仔细阅读了代码之后，做了2轮优化。1，递归是非常消耗资源的，仔细观察杨辉三角为对称结构，因此只需要递归其中一半的数据就可以，另外一半通过循环直接赋值；2，再仔细观察发现每一行的第二个和倒数第二个值为行数的值减一，这个特殊的地方可以直接返回计算值，而不需要递归计算，减少性能消耗。两次优化之后，终于提交成功
     
     
     思路：
     1、特殊情况，当numRows为0，则返回[]
     2、第一行为[1]
     3、从第二行开始计算，获取上一层的数组，由于首尾必为1，然后从第二位开始计算截止倒数第二位，即preRow[j-1]+preRow[j]，
     
     **/
    func generate(_ numRows: Int) -> [[Int]] {

        var result: [[Int]] = []
//        if numRows == 0 {
//            return result
//        }
//        result.append([1])
//        for i in 1..<numRows {
//            var row: [Int] = []
//            let preRow: [Int] = result[i-1]
//            row.append(1)
//            for j in 1..<i-1 {
//                row.append(preRow[j-1]+preRow[j])
//            }
//            row.append(1)
//            result.append(row)
//        }
//        return result
        
        if numRows == 0 {
            return result
        }
        for i in 0..<numRows {
            result.append(self.getRow(i))
        }
        return result
 
    }
    
    /*
     根据索引获取行数
     获取杨辉三角的指定行
     直接使用组合公式C(n,i) = n!/(i!*(n-i)!)
     则第(i+1)项是第i项的倍数=(n-i)/(i+1);
     **/
    func getRow(_ rowIndex: Int) -> [Int] {
        // 公式法
//        var result: [Int] = []
//        var num = 1
//        for i in 0...rowIndex {// 第n行有n个数
//            result.append(num)
//            num = num * (rowIndex-i)/(i+1)
//        }
//        return result
        
        
        //j行的数据, 应该由j - 1行的数据计算出来.
        //假设j - 1行为[1,3,3,1], 那么我们前面插入一个0(j行的数据会比j-1行多一个),
        //然后执行相加[0+1,1+3,3+3,3+1,1] = [1,4,6,4,1], 最后一个1保留即可.
        var result: [Int] = [1]
        
        for i in 1..<rowIndex+1 {// 索引是从o0开始的，故需加上1
            result.insert(0, at: 0)
            for j in 0..<i {
                result[j] = result[j] + result[j+1]
            }
        }
        return result
        
    }
    
    /*
     很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。

     这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。

     先随便抽出一道题，看看别人的解法：

     int maxProfit(vector<int>& prices) {
         if(prices.empty()) return 0;
         int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;
             
         for(int i=1;i<prices.size();++i) {
             s1 = max(s1, -prices[i]);
             s2 = max(s2, s1+prices[i]);
             s3 = max(s3, s2-prices[i]);
             s4 = max(s4, s3+prices[i]);
         }
         return max(0,s4);
     }
     能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。

     本文就来告诉你这个框架，然后带着你一道一道秒杀。

     这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。

     第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。

     一、穷举框架

     首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。

     递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。

     而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。

     for 状态1 in 状态1的所有取值：
         for 状态2 in 状态2的所有取值：
             for ...
                 dp[状态1][状态2][...] = 择优(选择1，选择2...)
     比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k > 0 的前提下操作。

     很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：

     dp[i][k][0 or 1]
     0 <= i <= n-1, 1 <= k <= K
     n 为天数，大 K 为最多交易数
     此问题共 n × K × 2 种状态，全部穷举就能搞定。

     for 0 <= i < n:
         for 1 <= k <= K:
             for s in {0, 1}:
                 dp[i][k][s] = max(buy, sell, rest)
     而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？

     我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。

     记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。

     二、状态转移框架

     现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。



     通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：

     dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
                   max(   选择 rest  ,           选择 sell      )

     解释：今天我没有持有股票，有两种可能：
     要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
     要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

     dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
                   max(   选择 rest  ,           选择 buy         )

     解释：今天我持有着股票，有两种可能：
     要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
     要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。
     这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。

     现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。

     dp[-1][k][0] = 0
     解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
     dp[-1][k][1] = -infinity
     解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
     dp[i][0][0] = 0
     解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
     dp[i][0][1] = -infinity
     解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
     把上面的状态转移方程总结一下：

     base case：
     dp[-1][k][0] = dp[i][0][0] = 0
     dp[-1][k][1] = dp[i][0][1] = -infinity

     状态转移方程：
     dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
     dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
     读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。

     三、秒杀题目

     第一题，k = 1

     直接套状态转移方程，根据 base case，可以做一些化简：

     dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
     dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i])
                 = max(dp[i-1][1][1], -prices[i])
     解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。

     现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
     可以进行进一步化简去掉所有 k：
     dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
     dp[i][1] = max(dp[i-1][1], -prices[i])
     直接写出代码：

     int n = prices.length;
     int[][] dp = new int[n][2];
     for (int i = 0; i < n; i++) {
         dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
         dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
     }
     return dp[n - 1][0];
     显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：

     for (int i = 0; i < n; i++) {
         if (i - 1 == -1) {
             dp[i][0] = 0;
             // 解释：
             //   dp[i][0]
             // = max(dp[-1][0], dp[-1][1] + prices[i])
             // = max(0, -infinity + prices[i]) = 0
             dp[i][1] = -prices[i];
             //解释：
             //   dp[i][1]
             // = max(dp[-1][1], dp[-1][0] - prices[i])
             // = max(-infinity, 0 - prices[i])
             // = -prices[i]
             continue;
         }
         dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
         dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
     }
     return dp[n - 1][0];
     第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):

     // k == 1
     int maxProfit_k_1(int[] prices) {
         int n = prices.length;
         // base case: dp[-1][0] = 0, dp[-1][1] = -infinity
         int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
         for (int i = 0; i < n; i++) {
             // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
             dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
             // dp[i][1] = max(dp[i-1][1], -prices[i])
             dp_i_1 = Math.max(dp_i_1, -prices[i]);
         }
         return dp_i_0;
     }
     两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。

     第二题，k = +infinity

     如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：

     dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
     dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
                 = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])

     我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
     dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
     dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
     直接翻译成代码：

     int maxProfit_k_inf(int[] prices) {
         int n = prices.length;
         int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
         for (int i = 0; i < n; i++) {
             int temp = dp_i_0;
             dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
             dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
         }
         return dp_i_0;
     }
     第三题，k = +infinity with cooldown

     每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：

     dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
     dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
     解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。
     翻译成代码：

     int maxProfit_with_cool(int[] prices) {
         int n = prices.length;
         int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
         int dp_pre_0 = 0; // 代表 dp[i-2][0]
         for (int i = 0; i < n; i++) {
             int temp = dp_i_0;
             dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
             dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);
             dp_pre_0 = temp;
         }
         return dp_i_0;
     }
     第四题，k = +infinity with fee

     每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：

     dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
     dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
     解释：相当于买入股票的价格升高了。
     在第一个式子里减也是一样的，相当于卖出股票的价格减小了。
     直接翻译成代码：

     int maxProfit_with_fee(int[] prices, int fee) {
         int n = prices.length;
         int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
         for (int i = 0; i < n; i++) {
             int temp = dp_i_0;
             dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
             dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);
         }
         return dp_i_0;
     }
     第五题，k = 2

     k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。

     这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。

     原始的动态转移方程，没有可化简的地方
     dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
     dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
     按照之前的代码，我们可能想当然这样写代码（错误的）：

     int k = 2;
     int[][][] dp = new int[n][k + 1][2];
     for (int i = 0; i < n; i++)
         if (i - 1 == -1) { /* 处理一下 base case*/ }
         dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
         dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
     }
     return dp[n - 1][k][0];
     为什么错误？我这不是照着状态转移方程写的吗？

     还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：

     int max_k = 2;
     int[][][] dp = new int[n][max_k + 1][2];
     for (int i = 0; i < n; i++) {
         for (int k = max_k; k >= 1; k--) {
             if (i - 1 == -1) {
                 /* 处理 base case */
                 dp[i][k][0] = 0;
                 dp[i][k][1] = -prices[i];
                 continue;
             }
             dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
             dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
         }
     }
     // 穷举了 n × max_k × 2 个状态，正确。
     return dp[n - 1][max_k][0];
     如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。

     这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：

     dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])
     dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])
     dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
     dp[i][1][1] = max(dp[i-1][1][1], -prices[i])

     int maxProfit_k_2(int[] prices) {
         int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;
         int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;
         for (int price : prices) {
             dp_i20 = Math.max(dp_i20, dp_i21 + price);
             dp_i21 = Math.max(dp_i21, dp_i10 - price);
             dp_i10 = Math.max(dp_i10, dp_i11 + price);
             dp_i11 = Math.max(dp_i11, -price);
         }
         return dp_i20;
     }
     有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。

     第六题，k = any integer

     有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？

     一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。

     直接把之前的代码重用：

     int maxProfit_k_any(int max_k, int[] prices) {
         int n = prices.length;
         if (max_k > n / 2)
             return maxProfit_k_inf(prices);

         int[][][] dp = new int[n][max_k + 1][2];
         for (int i = 0; i < n; i++)
             for (int k = max_k; k >= 1; k--) {
                 if (i - 1 == -1) {
                     /* 处理 base case */
                     dp[i][k][0] = 0;
                     dp[i][k][1] = -prices[i];
                     continue;
                 }
                 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
             }
         return dp[n - 1][max_k][0];
     }
     至此，6 道题目通过一个状态转移方程全部解决。

     四、最后总结
     本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。

     关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？

     具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。

     所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。
     
     **/
    
    
        ///121. 买卖股票的最佳时机
        /*
         给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

         如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

         注意你不能在买入股票前卖出股票。

         int n = prices.length;
         // base case: dp[-1][0] = 0, dp[-1][1] = -infinity
         int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
         for (int i = 0; i < n; i++) {
             // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
             dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
             // dp[i][1] = max(dp[i-1][1], -prices[i])
             dp_i_1 = Math.max(dp_i_1, -prices[i]);
         }
         return dp_i_0;
         **/
        func maxProfit(_ prices: [Int]) -> Int {
            // i:天，0:卖，1:买，k:买、卖次数
            // dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])      卖出后利润
            //                      rest            sell
    //        解释：今天我没有持有股票，有两种可能：
    //        要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
    //        要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。
            
            // dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])    买入后利润
            //                      rest            buy
    //        解释：今天我持有着股票，有两种可能：
    //        要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
    //        要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。
            
            if prices.count == 0 {
                return 0
            }
            
            var dp_i_0 = 0, dp_i_1 = Int.min
            for i in 0..<prices.count {
                dp_i_0 = max(dp_i_0, dp_i_1 + prices[i])    // 卖出后利润
                dp_i_1 = max(dp_i_1, -prices[i])            // 买入后利润
            }
            
            return dp_i_0
            
            
            // 方法2
            
//            if prices.count < 2 {
//                return 0
//            }
//
//            var minPrices = prices.first!
//            var maxProfit = 0
//
//            for price in prices {
//                if price <= minPrices {
//                    minPrices = price
//                }else {
//                    let profit = price - minPrices
//                    maxProfit = max(maxProfit, profit)
//                }
//            }
//            return maxProfit
            
        }
        
    /// 122. 买卖股票的最佳时机 II，可以多次买卖
    /*
    我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
    dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
    dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
    **/
    func maxProfit2(_ prices: [Int]) -> Int {
        
        if prices.count == 0  {
            return 0
        }
        
        var dp_i_0 = 0, dp_i_1 = Int.min
        for i in 0..<prices.count {
            let temp = dp_i_0; // 昨日卖出后利润
            dp_i_0 = max(dp_i_0, dp_i_1 + prices[i])    // 今日卖出后利润
            dp_i_1 = max(dp_i_1, temp-prices[i])        // 今日买入后利润
        }
        
        return dp_i_0
        
        
        
        if prices.count == 0  {
            return 0
        }
        var maxProfit = 0
        // 相邻元素直接的正差值总和即为最大值
        for i in 1..<prices.count {
            if prices[i] > prices[i-1] {
                maxProfit += prices[i] - prices[i-1]
            }
        }
        return maxProfit
        
    }
    
    
    /// 125. 验证回文串
    func isPalindrome(_ s: String) -> Bool {
        
        
        
        
        return false
    }
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    /// 22. 括号生成
//    func generateParenthesis(_ n: Int) -> [String] {
//        if n == 0 {
//            return []
//        }
//        var total_l: [[String]] = []
//        total_l.append([""])                    // 0组括号时记为None
//        total_l.append(["()"])                  // 1组括号只有一种情况
//
//        for i in 2..<n+1 {                      // 开始计算i组括号时的括号组合
//            var l: [String] = []
//            for j in 0..<i {                    // 开始遍历 p q ，其中p+q=i-1 , j 作为索引
//                let now_list1 = total_l[j]      // p = j 时的括号组合情况
//                let now_list2 = total_l[i-1-j]  // q = (i-1) - j 时的括号组合情况
//
//                for var k1 in now_list1 {
//                    for var k2 in now_list2 {
//                        if k1.isEmpty {
//                            k1 = ""
//                        }else if k2.isEmpty {
//                            k2 = ""
//                        }else {
//                            let el = "(" + k1 + ")" + k2
//                            l.append(el)
//                        }
//                    }
//                }
//            }
//            total_l.append(l)
//        }
//
//        return total_l[n]
//    }
    
    
    /**
    异或运算的规则是：如果不同就得1，如果相同则得0。利用这个特性，遍历异或整个数组的所有元素，那么出现次数为偶数的数字经过异或后等于0，剩下的数字即是数组中只出现一次的数字.    利用异或运算只需要一次for循坏，并且不需要额外的空间。
    */
    /// 136. 只出现一次的数字
    func singleNumber(_ nums: [Int]) -> Int {
        var single = 0
        for num in nums {
            single = num ^ single
            print("single:\(single), num:\(num)")
        }
        print(single)
        return single
    }
    
    
    
    
    /*
    // MARK: - Navigation

    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destination.
        // Pass the selected object to the new view controller.
    }
    */

}
